#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = ["click>=8.0", "pydantic>=2.0"]
# ///
"""Memory management CLI - invalid states unrepresentable via Pydantic"""

from __future__ import annotations
import json
import click
from datetime import datetime
from enum import Enum
from pathlib import Path
from pydantic import BaseModel, Field, field_validator
from typing import Literal, Optional


# === TYPES: Pydantic makes invalid states unrepresentable ===

class EntityType(str, Enum):
    PROJECT = "project"
    DOMAIN = "domain"
    PATTERN = "pattern"
    FLOW = "flow"
    RISK = "risk"


class EntityMeta(BaseModel):
    """Entity metadata - Pydantic validates all constraints"""
    type: Literal["meta"] = "meta"
    id: str
    entity_type: EntityType
    created: datetime
    confidence: float = Field(ge=0.0, le=1.0)  # MUST be 0.0-1.0
    last_used: datetime
    use_count: int = Field(ge=1)  # MUST be >= 1


class Observation(BaseModel):
    """Observation - Pydantic ensures content exists and is non-empty"""
    type: Literal["observation"] = "observation"
    content: str = Field(min_length=1)  # Can't be empty
    added: datetime
    evidence: Optional[str] = None


class Relation(BaseModel):
    from_entity: str = Field(alias="from")
    to_entity: str = Field(alias="to")
    relation_type: str = Field(alias="type")
    created: datetime


# === CONSTANTS ===

MEMORY_DIR = Path(".claude/memory")


# === HELPERS ===

def entity_file(entity_type: EntityType, name: str) -> Path:
    return MEMORY_DIR / entity_type.value / f"{name}.jsonl"


# === COMMANDS ===

@click.group()
def cli():
    """Memory management for persistent project knowledge"""
    pass


@cli.command()
@click.argument("entity_type", type=click.Choice([t.value for t in EntityType]))
@click.argument("name")
@click.argument("observation")
@click.option("--evidence", help="Evidence file/commit reference")
@click.option("--confidence", type=float, default=0.7, help="Confidence 0.0-1.0")
def create(entity_type: str, name: str, observation: str, evidence: Optional[str], confidence: float):
    """Create new entity with first observation"""
    etype = EntityType(entity_type)
    file_path = entity_file(etype, name)

    if file_path.exists():
        click.echo(f"Error: {etype.value}:{name} already exists", err=True)
        raise SystemExit(1)

    file_path.parent.mkdir(parents=True, exist_ok=True)
    now = datetime.now()

    # Pydantic validates - will raise if invalid
    meta = EntityMeta(
        id=f"{etype.value}:{name}",
        entity_type=etype,
        created=now,
        confidence=confidence,
        last_used=now,
        use_count=1
    )

    obs = Observation(
        content=observation,
        added=now,
        evidence=evidence
    )

    with file_path.open("w") as f:
        f.write(meta.model_dump_json() + "\n")
        f.write(obs.model_dump_json(by_alias=True) + "\n")

    click.echo(f"✓ Created {meta.id}")


@cli.command()
@click.argument("entity_type", type=click.Choice([t.value for t in EntityType]))
@click.argument("name")
@click.argument("observation")
@click.option("--evidence", help="Evidence file/commit reference")
def add(entity_type: str, name: str, observation: str, evidence: Optional[str]):
    """Add observation to existing entity"""
    etype = EntityType(entity_type)
    file_path = entity_file(etype, name)

    if not file_path.exists():
        click.echo(f"Error: {etype.value}:{name} not found", err=True)
        click.echo(f"Hint: Use 'memory create {etype.value} {name} \"...\"'", err=True)
        raise SystemExit(1)

    obs = Observation(content=observation, added=datetime.now(), evidence=evidence)

    # Update meta (increment use_count, update last_used)
    lines = file_path.read_text().splitlines()
    meta = EntityMeta.model_validate_json(lines[0])
    meta = meta.model_copy(update={"use_count": meta.use_count + 1, "last_used": datetime.now()})

    with file_path.open("w") as f:
        f.write(meta.model_dump_json() + "\n")
        f.writelines(line + "\n" for line in lines[1:])
        f.write(obs.model_dump_json(by_alias=True) + "\n")

    click.echo(f"✓ Added observation to {etype.value}:{name}")


@cli.command()
@click.argument("search_term")
def query(search_term: str):
    """Search all entities"""
    if not MEMORY_DIR.exists():
        click.echo("No memory found")
        return

    results = []
    for jsonl_file in MEMORY_DIR.rglob("*.jsonl"):
        content = jsonl_file.read_text()
        if search_term.lower() in content.lower():
            lines = content.splitlines()
            if lines:
                meta = json.loads(lines[0])
                results.append(meta["id"])

    if not results:
        click.echo(f"No entities found matching '{search_term}'")
        return

    click.echo(f"Found {len(results)} entities:\n")
    for entity_id in results:
        click.echo(f"  {entity_id}")


@cli.command()
@click.argument("entity_type", type=click.Choice([t.value for t in EntityType]))
@click.argument("name")
def show(entity_type: str, name: str):
    """Show full entity details"""
    etype = EntityType(entity_type)
    file_path = entity_file(etype, name)

    if not file_path.exists():
        click.echo(f"Error: {etype.value}:{name} not found", err=True)
        raise SystemExit(1)

    lines = file_path.read_text().splitlines()
    meta = EntityMeta.model_validate_json(lines[0])

    click.echo(f"\n# {meta.id}")
    click.echo(f"Created: {meta.created}")
    click.echo(f"Confidence: {meta.confidence}")
    click.echo(f"Last used: {meta.last_used}")
    click.echo(f"Use count: {meta.use_count}\n")
    click.echo("## Observations\n")

    for line in lines[1:]:
        obs = Observation.model_validate_json(line)
        click.echo(f"- {obs.content}")
        if obs.evidence:
            click.echo(f"  Evidence: {obs.evidence}")
    click.echo()


@cli.command(name="list")
@click.argument("entity_type", type=click.Choice([t.value for t in EntityType]), required=False)
def list_cmd(entity_type: Optional[str]):
    """List all entities, optionally filtered by type"""
    if not MEMORY_DIR.exists():
        click.echo("No memory found")
        return

    if entity_type:
        dirs = [MEMORY_DIR / entity_type]
    else:
        dirs = [d for d in MEMORY_DIR.iterdir() if d.is_dir()]

    for dir_path in sorted(dirs):
        if not dir_path.is_dir():
            continue

        files = [*dir_path.glob("*.jsonl")]
        if not files:
            continue

        click.echo(f"\n{dir_path.name}/")
        for file_path in sorted(files):
            lines = file_path.read_text().splitlines()
            if lines:
                meta = EntityMeta.model_validate_json(lines[0])
                click.echo(f"  {meta.id} (confidence: {meta.confidence})")


if __name__ == "__main__":
    cli()
